# Контекст вызова и замыкания

* Работа с 'this' (4 способа использования)
* Использование 'call', 'apply'
* Работа с 'bind', карринг и полифилл
* Дескрипторы, геттеры и сеттеры свойств
* Шаблон проектирования 'Singletone' через замыкание
* Сборщик мусора
* Всплытие

## this
this - это ключевое слово, которое определяет, в каком контексте вызывается функция. Иными словами, this показывает,
откуда была вызывана функция.
Сущестуют 4 варианта, откуда может быть функция:
 * Из глобальной или локальной области видимости. Иными словам, просто обычный вызов функции.
 * Как метод объекта
 * С помощью методов call, apply
 * Как instance класса.
 
 this вычисляется динамически, в момент вызова функции. То есть не важно где было использован this. Он будет
 вычеслен именно в момент вызова функции, а не в момент объявления. Это очень важно.
 
Давайте разберемся немного подробнее:
Когда мы вызываем функцию как функцию, без use strict, this будет window.
Если при вызове функции был включен use strict, тогда this будет undefined.

Если мы вызываем функцию из объекта, this будет указывать на этот самый объект.

С помощью call и apply мы можем явно указать какой будет this.

При использовании this в рамках инстанса класса, this будет указывать как раз таки на этот самый инстанс.

## Каррирование
Каррирование - это прием, позволяющий создать функцию, при этом как бы "вшить" в нее какой-то аргумент, который будет
доступен в последующих функциях без его указания. 
Каррирование - это частная реализация паттерна функции-оббертки (декоратор).
Проще всего понять - посмотреть на примере.

## Singleton — одиночка

Одиночка (англ. Singleton) — шаблон проектирования, гарантирующий что в приложении будет единственный
экземпляр класса с глобальной точкой доступа.

Иначе говоря, сколько б раз вы не вызывали new User(), все время будет возвращаться только один и тот же инстанс.

## Сборщик мусора
Каждая переменная, вычисления или какие-то операции занимют память компьютера. Есть специальный инструмент,
сборщик мусора, который следит за памятью и при возможности может частично ее очищстить.

Если же значение является достижимое, иными словами доступны и используются, то такие переменные не будут удаляться.
Каждый движок работает по своему и сборка мусора происходит автоматически. Поэтому, по большому счету мы не можем ее
предотвратить.


## Дескрипторы, геттеры и сеттеры свойств
Object.defineProperty(obj, prop, descriptor)

Аргументы:
* obj - объект, в котором объявляется свойство.
* prop - имя свойства, которое нужно объявить или модифицировать.
* descriptor - дескриптор – объект, который описывает поведение свойства.

Примеры:
1. простое присваивание
user.name = "Вася";

2. указание значения через дескриптор
Object.defineProperty(user, "name", { value: "Вася", configurable: true, writable: true, enumerable: true });
